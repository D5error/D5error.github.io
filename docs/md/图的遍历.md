## 1. 深度优先搜索DFS

```
void Visit(Vertex V)
{
    printf("正在访问顶点%d\n",V);
}
void DFS(LGraph Graph,Vertex V)
{
    PtrToAdjVNode W;
    Visit(V);
    Visited[V]=true;
    for(W=Graph->G[V].FirstEdge;W;W=W->Next)
    {
        if(!Visited[W->AdjV])
        {
            DFS(Graph,W->AdjV); 
        }
    }
}
```

## 2. 广度优先搜索BFS

```
bool IsEdge(MGraph Graph,Vertex V,Vertex W)
{
    return Graph->G[V][W]<INFINITY?true:false;
}
void BFS(MGraph Graph,Vertex S)
{
    Queue Q;
    Vertex V,W;
    Q=CreateQueue(MAXSIZE);
    Visit(S);
    Visited[S]=true;
    AddQ(Q,S);
    while(!IsEmpty(Q))
    {
        V=DeleteQ(Q);
        for(W=0;W<Graph->Nv;W++)
        {
            if(!Visited[W]&&IsEdge(Graph,V,W))
            {
                Visit(W);
                Visited[W]=true;
                AddQ(Q,W);
            }
        }
    }
}
```

## 3. 概念

* 连通:从V到W存在一条(无向)路径,则V和W是连通的
* 路径:V到W的路径是一系列顶点的集合,其中任一对相邻的顶点间都有图中的边
    * 路径的长度:路径中的边数(如果带有权,则是所有边的权重和)
    * 简单路径:V到W之间和所有顶点都不同
* 回路:起点等于终点的路径
* 连通图:图中任意两顶点均连通
* 连通分量:无向图的极大连通子图
    * 极大顶点数:再加1个顶点就不连通
    * 极大边数:包含子图中所有顶点相邻的边
* 强连通:有向图中V和W之间存在双向路径
* 强连通图:有向图中任意两顶点均强连通
* 强连通分量:有向图的极大强连通子图
* 弱连通:
* 弱连通图:
* 弱连通分量:
