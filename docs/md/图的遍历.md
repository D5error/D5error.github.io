# 深度优先搜索DFS
* 一直朝一个没被标记过的方向走，如果四周全被标记过，则原路返回直到遇到有没被标记过的方向，最终返回终点

```cpp
void DFS(LGraph Graph,Vertex V)
{
    if(Visited[V])//已经访问过
    {
        return;
    }
    Visited[u]=true;//对已访问结点进行标记
    //递归思想：对当前结点的周围所有未访问的结点从小到大进行DFS，直到四周都被访问
    for(int i=0;i<Graph->NumVertex;++i)
    {
        //i从0迭代到NumVertex，用于找到目前顶点已经存在的边，并且从小往大寻找
        if(!Visited[i]&&Graph->G[u][i]!=INFNITY)
        {
            DFS(i);
        }
    }
}
```

# 广度优先搜索BFS
* 类似二叉树层序遍历，从起点开始一层一层访问，直到最后一层

```cpp
void BFS(MGraph Graph,Vertex S)
{
    Queue Q=CreateQueue(MAXSIZE);
    Visit(S);
    Visited[S]=true;//标记当前结点
    AddQ(Q,S);//入栈，用于下一层访问
    while(!IsEmpty(Q))
    {
        Vertex V=DeleteQ(Q);
        for(Vertex W=0;W<Graph->NumVertex;W++)
        {
            if(!Visited[W]&&Graph->G[V][W]!=INFNITY)
            {
                Visit(W);
                Visited[W]=true;
                AddQ(Q,W);
            }
        }
    }
}
```

# 概念

* 连通：从V到W存在一条（无向）路径，则V和W是连通的

* 路径：V到W的路径是一系列顶点的集合，其中任一对相邻的顶点间都有图中的边
    * 路径的长度：路径中的边数（如果带有权，则是所有边的权重和）

    * 简单路径：V到W之间和所有顶点都不同

* 回路:起点等于终点的路径

* 连通图：图中任意两顶点均连通

* 连通分量：无向图的极大连通子图
    * 极大顶点数:再加1个顶点就不连通
    * 极大边数:包含子图中所有顶点相邻的边
* 强连通:有向图中V和W之间存在双向路径
* 强连通图:有向图中任意两顶点均强连通
* 强连通分量:有向图的极大强连通子图
* 弱连通:
* 弱连通图:
* 弱连通分量:
