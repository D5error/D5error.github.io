## 1. 什么是堆栈

* 具有一定操作约束的线性表
* 只在一段(栈顶)做插入(入栈)/删除(出栈) 

## 2. 堆栈的实现

> ### *利用数组存放元素*

```
typedef struct SNode *Stack;
struct SNode
{
    ElementType Data[MAXSIZE];
    int Top;
};
```

* 入栈

```
void Push(Stack PtrS,ElementType item)
{
    if(PtrS->Top==MAXSIZE-1)
    {
        printf("堆栈满");
        return;
    }
    PtrS->Data[++(PtrS->Top)]=item;
    return;
}
```

* 出栈

```
ElementType Pop(Stack PtrS)
{
    if(PtrS->Top==-1)
    {
        printf("堆栈空");
        return ERROR;    //ERROR是ElementType的特殊值,标志错误
    }
    return PtrS[PtrS->Data[(PtrS->Top)--];
}
```

> ### *利用"链"存放元素*

```
typedef struct SNode *Stack;
struct SNode
{
    ElementType Data;
    struct SNode *Next;
};
```

* 堆栈初始化(建立空栈)

```
Stack CreateStack()
{
    Stack S;
    S=(Stack)malloc(sizeof(struct SNode));
    S->Next=NULL;
    return S;
}
```

* 判断堆栈S是否为空

```
int IsEmpty(Stack S)
{
    return S->Next==NULL;    //若为空返回1,否则返回0
}
```
* 入栈

```
void Push(ElementType item,Stack S)
{
    struct SNode *TmpCell;
    TmpCell=(struct SNode *)malloc(sizeof(struct SNode));
    TmpCell->Element=item;
    TmpCell->Next=S->Next;
    S->Next=TmpCell;
}
```

* 出栈

```
ElementType Pop(Stack S)
{
    struct SNode *FirstCell;
    ElementType TopElem;
    if(IsEmpty(S))
    {
        printf("堆栈空");
        return NULL;
    }
    FirstCell=S->Next;
    S->Next=FirstCell->Next;
    TopElem=FirstCell->Element;
    free(FirstCell);
    return TopElem;
}
```

## 3. 中缀表达式转化为后缀表达式
    2*(6/3+4)-5  

* 规则
    * 优先级:乘=除>加=减
    * 对于新对象是数字:直接输出
    * 对于新对象是高优先级:直接入栈
    * 对于新对象是低或同优先级:栈顶出栈并输出,再同新栈顶比较
    * 对于新对象是左括号:在栈外为最高优先级,在栈内为最低优先级
    * 对于新对象是右括号:持续将栈顶出栈并输出,直到遇到左括号为止,括号始终不输出
    * 无新对象时,持续将栈顶出栈并输出

|栈:|输出|
|:-|:-|
|NULL|2|
|*|2|
|* (|2|
|* (|2 6|
|* ( /|2 6|
|* ( /|2 6 3|
|* (|2 6 3 /|
|* ( +|2 6 3 /| 
|* ( +|2 6 3 / 4|
|* (|2 6 3 / 4 +|
|*|2 6 3 / 4 +|
|NULL|2 6 3 / 4 + *|
|-|2 6 3 / 4 + *|
|-|2 6 3 / 4 + * 5|
|NULL|2 6 3 / 4 + * 5 -|
