# 什么是堆栈
* 具有一定操作约束的线性表
* 只在一段(栈顶)做插入(入栈)/删除(出栈) 

# 2. 堆栈的实现
## 利用数组存放元素
```c
struct SNode
{
    ElementType Data[MAXSIZE];
    int Top;    //栈顶位置
};
typedef struct SNode *Stack;
```
* 入栈
    ```c
    void Push(Stack PtrS,ElementType item)
    {
        if(PtrS->Top==MAXSIZE-1)
        {
            printf("堆栈满");
            return;
        }
        PtrS->Data[++(PtrS->Top)]=item;
        return;
    }
    ```
* 出栈
    ```c
    ElementType Pop(Stack PtrS)
    {
        if(PtrS->Top==-1)
        {
            printf("堆栈空");
            return ERROR;    //ERROR是ElementType的特殊值,标志错误
        }

        return PtrS[PtrS->Data[(PtrS->Top)--]];
    }
    ```
## 利用"链"存放元素
```c
struct SNode
{
    ElementType Data;
    struct SNode *Next;
};
typedef struct SNode *Stack;
```
* 堆栈初始化(建立空栈)
    ```c
    Stack CreateStack()
    {
        Stack S;
        S=(Stack)malloc(sizeof(struct SNode));
        S->Next=NULL;
        return S;
    }
    ```
* 判断堆栈S是否为空
    ```c
    int IsEmpty(Stack S)
    {
        return S->Next==NULL;    //若为空返回1,否则返回0
    }
    ```
* 入栈
    ```c
    void Push(ElementType item,Stack S)
    {
        struct SNode *TmpNode;
        TmpNode=(struct SNode*)malloc(sizeof(struct SNode));
        TmpNode->Element=item;
        TmpNode->Next=S->Next;
        S->Next=TmpNode;
    }
    ```
* 出栈
    ```c
    ElementType Pop(Stack S)
    {
        struct SNode *FirstNode;
        ElementType TopElem;
        if(IsEmpty(S))
        {
            printf("堆栈空");
            return NULL;
        }
        FirstNode=S->Next;
        S->Next=FirstNode->Next;
        TopElem=FirstNode->Element;
        free(FirstNode);    //释放内存空间
        return TopElem;
    }
    ```
## 3. 表达式
1. 前缀表达式:运算符位于操作数之前
    * 从**右至左**扫描表达式,遇到数字时,将数字压入堆栈,遇到运算符时,弹出栈顶的两个数,用运算符进行运算,并将结果入栈,直到表达式最左端,输出结果

        |未读取的输入|栈|
        |:-|:-|
        |- * + 3 4 5 6 ||
        |- * + 3 4 5 |6 |
        |- * + 3 4 |6 5 |
        |- * + 3 |6 5 4 |
        |- * + |6 5 4 3 |
        |- * |6 5 7|
        |- |6 35|
        ||29 |

2. 中缀表达式:运算符位于操作数之间
3. 后缀表达式:运算符位于操作数之后
    * 从**左至右**扫描表达式,遇到数字时,将数字压入堆栈,遇到运算符时,弹出栈顶的两个数,用运算符进行运算,并将结果入栈,直到表达式的最右端,输出结果

        |未读取的输入|栈|
        |-:|:-|
        |2 3 8 + 4 * * ||
        |3 8 + 4 * * |2 |
        |8 + 4 * * |2 3 |
        |+ 4 * * |2 3 8 |
        |4 * * |2 11 |
        |* * |2 11 4 |
        |* |2 44 |
        ||88 |

4. 中缀表达式转换后缀表达式规则
    * 优先级:乘=除>加=减
    * 对象是数字:直接输出
    * 对象是高优先级:直接入栈
    * 对象是低或同优先级:栈顶出栈并输出,再同新栈顶比较
    * 对象是左括号:在**栈外**为**最高优先级**,在**栈内**为**最低优先级**
    * 对象是右括号:持续将栈顶出栈并输出,直到遇到左括号为止,括号始终不输出
    * 无新对象时,持续将栈顶出栈并输出

        |未读取的输入|栈:|输出|
        |-:|:-|:-|
        |2*(6/3+4)-5|||
        |*(6/3+4)-5||2 |
        |(6/3+4)-5|*|2 |
        |6/3+4)-5|*(|2|
        |/3+4)-5|*(|2 6 |
        |3+4)-5|*(/|2 6 |
        |+4)-5|*(/|2 6 3 |
        |4)-5|*(+|2 6 3 / |
        |)-5|*(+|2 6 3 / 4| 
        |-5|*|2 6 3 / 4 + |
        |5|-|2 6 3 / 4 + * |
        ||-|2 6 3 / 4 + * 5 |
        |||2 6 3 / 4  + * 5 - |
