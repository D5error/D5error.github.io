## 1. 类型转换构造函数

* 只有一个参数,而且不是复制构造函数的构造函数,一般就可以看作是类型转换构造函数
* 当需要时,编译系统会自动调用转换构造函数,建立一个无名的临时对象(或临时变量)

```
class Complex
{
    public:
        double real,imag;
        Complex(int i)
        {
            cout<<"IntConstrutor called"<<endl;
            real=i;
            imag=0;
        }
        Complex(double r,double i)
        {
            real=r;
            imag=i;
        }
};
int main()
{
    Complex c1(7,8);
    Complex c2=12;
    c1=9;    //9被自动转换成一个临时Complex对象
    cout<<c1.real<<","<<c1.imag<<endl;
    return 0;
}
```

## 2. 析构函数

* 名字与类名相同,在前面加`~`,没有参数和返回值,一个类最多只能有一个析构函数
* 析构函数对象消亡时自动调用
* 若定义类时无析构函数,则编译器生成缺省析构函数,缺省析构函数什么都不做
* 若定义了析构函数,则编译器不生成缺省析构函数

```
class String
{
    private:
        char *p;
    public:
        String()
        {
            p=new char[10];
        }
        ~String()
};
String::~String()
{
    delete []p;
}
```

* 对象数组生命期结束时,对象数组的每个元素的析构函数都会被调用
* 参数对象消亡也会导致析构函数被调用
* 函数调用的返回值(临时对象)被用过后,该临时对象析构函数被调用