## 1. 二叉树的重要性质

* 一个二叉树第i层的最大结点数为2^(i-1),i>=1
* 深度为k的二叉树有最大结点**总数**为2^k-1,k>=1

## 2. 二叉树的实现

```
typedef struct TreeNode *BinTree;
typedef BinTree Position;
struct TreeNode
{
    ElementType Data;
    BinTree Left;
    BinTree Right;
};
```

## 3. 二叉树的递归遍历

> ### *先序遍历*

* 访问根结点
* 先序遍历其左子树
* 先序遍历其右子树

```
void PreOrderTraversal(BinTree BT)
{
    if(BT)
    {
        printf("%d",BT->Data);
        PreOrderTraversal(BT->Left);
        PreOrderTraversal(BT->Right);
    }
}
```

> ### *中序遍历*
> 
* 中序遍历其左子树
* 访问根结点
* 中序遍历其右子树

```
void InOrderTraversal(BinTree BT)
{
    if(BT)
    {
        InOrderTraversal(BT->Left);
        printf("%d",BT->Data);
        InOrderTraversal(BT->Right);
    }
}
```

> ### *后序遍历*
> 
* 后序遍历其左子树
* 后序遍历其右子树
* 访问根结点

```
void PostOrderTraversal(BinTree BT)
{
    PostOrderTraversal(BT->Left);
    PostOrderTraversal(BT->Right);
    printf("%d",BT->Data);
}
```

## 4. 二叉树的非递归遍历

> ### *中序遍历*

```
void InOrderTraversal(BinTree BT)
{
    Bintree T=BT;
    Stack S=CreateStack(MAXSIZE);
    while(T||!IsEmpty(S))
    {
        while(T)
        {
            Push(S,T);
            T=T->Left;
        }
        if(!IsEmpty(S))
        {
            T=Pop(S);
            printf("%5d",T->Data);
            T=T->Right;
        }
    }
}
```

> ### *先序遍历*

```
void PreOrderTraversal(BinTree BT)
{
    BinTree T=BT;
    Stack S=CreateStack(MAXSIZE);
    while(T||!IsEmpty(S))
    {
        while(T)
        {
            printf("%5d",T->Data);
            Push(S,T);
            T=T->Left;
        }
        if(!IsEmpty(S))
        {
            T=Pop(S);
            T=T->Right;
        }
    }
}
```

> ### *后序遍历* 

# 此代码80%概率出现错误,以后解决

```
PostOrderTraversal(BinTree BT)
{
    BinTree T=BT,LastVisited=NULL;
    Stack S=CreateStack(MAXSIZE);
    while(!IsEmpty(S))
    {
        while(T)
        {
            Push(S,T);
            T=T->Left;
        }
        if(!IsEmpty(S))
        {
            BinTree Temp=Top(S);
            if(Temp->Right&&Temp->Right!=LastVisited)
            {
                T=Temp->Right;
            }
            else
            {
                Pop(S);
                printf("%5d",Temp->Data);
                LastVisited=Temp;
            }
        }
    }
}
```

## 5. 二叉树的层序遍历

> ### *队列实现*

* 遍历从根结点开始,首先根结点入队,然后开始执行循环:结点入队,访问该结点,其左右结点入队

```
void LevelOrderTraversal(BinTree BT)
{
    Queue Q;
    BinTree T;
    if(!BT)
    {
        return;
    }
    Q=CreatQueue(MAXSIZE);
    AddQ(Q,BT);
    while(!IsEmpty(Q))
    {
        T=DeleteQ(Q);
        printf("%d\n",T->Data);
        if(T->Left)
        {
            AddQ(Q,T->Left);
        }
        if(T->Right)
        {
            AddQ(Q,T->Right);
        }
    }
}
```
