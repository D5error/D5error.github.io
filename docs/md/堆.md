# 什么是优先队列
* 优先队列：特殊的队列，取出元素的顺序是依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序（类似对字典的key排序）

# 堆的两个特性
* 结构性：用**数组**表示的**完全二叉树**
* 有序性：任一结点的关键字是其子树所有结点的**最大值**（或**最小值**）

# 最大堆的操作

```cpp
typedef struct HeapStruct *MaxHeap;
struct HeapStruct
{
    ElementType *Elements;    //存储堆元素的数组
    int Size;    //元素个数
    int Capacity;
};
```

* 最大堆的创建

```cpp
MaxHeap Create(int MaxSize)
{
    MaxHeap H=new Node;
    H->Elements=malloc((MaxSize+1)*sizeof(ElementType));
    H->Size=0;
    H->Capacity=MaxSize;
    H->Elements[0]=MaxData;
    return H;
}
```

* 最大堆的插入

```
void Insert(MaxHeap H,ElementType item)
{
    int i;
    if(IsFull(H))
    {
        printf("最大堆已满");
        return;
    }
    i=++H->Size;
    for(;H->Elements[i/2]<item;i/=2)    //本来需要循环条件i>1,但有哨兵H->Elements[0]代替了
    {
        H->Elements[i]=H->Elements[i/2];
    }
    H->Elements[i]=item;
}
```

* 最大堆的删除

```
ElementType DeleteMax(MaxHeap H)
{
    int Parent,Child;
    ElementType MaxItem,temp;
    if(IsEmpty(H))
    {
        printf("最大堆已空");
        return;
    }
    MaxItem=H->Elements[1];
    temp=H->Elements[H->Size--];
    for(Parent=1;Parent*2<=H->Size;Parent=Child)
    {
        Child=Parent*2;
        if((Child!=H->Size)&&(H->Elements[Child]<H->Elements[Child+1]))
        {
            Child++;
        }
        if(temp>=H->Elements[Child])
        {
            break;
        }
        else
        {
            H->Elements[Parent]=H->Elements[Child];
        }
    }
    H->Elements[Parent]=temp;
    return MaxItem;
}
```
 
* 建造最大堆

```
void PercDown(MaxHeap H,int p)    //下滤:将H中以H->Data[p]为根的子堆调整为最大堆
{
    int Parent,Child;
    ElementType X;
    X=H->Data[p];
    for(Parent=p;Parent*2<=H->Size;Parent=Child)
    {
        Child=Parent*2;
        if((Child!=H->Size)&&(H->Data[Child]<H->Data[Child+1]))
        {
            Child++;
        }
        if(X>=H->Data[Child])
        {
            break;
        }
        else
        {
            H->Data[Parent]=H->Data[Child];
        }
        H->Data[Parent]=X;
    }
}
void BuildHeap(MaxHeap H)
{
    int i;
    for(i=H->Size/2;i>0;i--)
    {
        PerDown(H,i);
    }
}
```
