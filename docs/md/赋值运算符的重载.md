# 赋值运算符的重载
* 赋值运算符 `=` 只能重载为**成员函数**

```cpp
class String
{
private:
    char *str;
public:
    ...
};
String &String :: operator =(const char *s)
{
    delete []str;
    str= new char[strlen(s)+1];
    strcpy(str,s);
    return *this;
}
```

# 浅拷贝和深拷贝
* 浅拷贝会产生的问题
    1. 如果不定义自己的赋值运算符，那么`S1 = S2`导致`S1.str`和`S2.str`指向同一地方

    2. 如果`S1`对象消亡，析构函数将释放`S1.str`指向的空间，则S2消亡时还要释放一次，会产生问题

    3. 另外，如果执行 `S1 = "other";` 将导致`S2.str`指向的地方会被`delete`

* 因此不能使用默认的浅拷贝，应自行实现一个深拷贝以以避免上面的问题
