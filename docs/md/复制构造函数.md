# 复制构造函数概念
* 只有一个参数，即对同类对象的引用
    * `X::(X &)`或`X::(const X &)`

* 如果没有定义复制构造函数，编译器**生成默认复制构造函数**，默认的复制构造函数完成复制功能

* 若定义的自己的复制构造函数，**则默认的复制构造函数不存在**

* **不允许有形如`X::X(X)`的复制构造函数**

```c
class Complex
{
    private:
        double real,imag;
};
Complex c1;    //调用缺省无参构造函数
Complex c2(c1);    //调用缺省的复制函数,将c2初始化和c1一样
```

## 复制构造函数起作用的三种情况

* 当用一个对象去初始化同类的另一个对象时

```c
Complex c2(c1);    //复制构造函数被调用
Complex c2=c1;    //初始化语句，复制构造函数被调用，而非幅值
```

* 如果某个函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用

```cpp
class A
{
    public:
        A(){};
        A(A &a)
        {
            cout<<"Copy constructor called"<<endl;
        }
};
void Func1(A a1){}
void Func2(A a1){}
int main()
{
    A a2;
    Func1(a2);
    Func2(a2);
    return 0;
}
```

* 如果函数的返回值是类A对象时，**则函数返回时，A的复制构造函数被调用**

```c
A Func()
{
    A b(4);
    return b;
}
```

* 对象间赋值并不导致复制构造函数被调用，就是简单的赋值
