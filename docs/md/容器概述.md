# 容器概述
* 可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是类模板，分为三种
1. 顺序容器
    * `vector`,`deque`,`list`
2. 关联容器
    * `set`,`multiset`,`map`,`multimap`
3. 容器适配器
    * `stack`,`queue`,`priority_queue`    
* 对象被插入容器中时，被插入的是对象的一个复制品。许多算法，比如排序、查找，要求对容器中的元素进行比较，有的容器本身就是排序的，所以放入容器的对象所属的类，往往还应该重载`==`和`<`运算符    
# 顺序容器简介
* 容器并非排序，元素的插入位置同元素的值无关
1. `vector`：头文件<vector>
    * 动态数组，元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能（大部分情况下是常数时间）![Alt text](image-36.png)    
2. `deque`：头文件<deque>
    * 双向队列，元素在内存连续存放。随机存取任何元素都能在常数时间完成（但次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）![Alt text](image-37.png)![Alt text](image-38.png)             
3. `list`：头文件<list>
    * 双向链表，元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取![Alt text](image-39.png)    
# 关联容器简介
* 元素是排序的
* 插入任何元素，都按照相应的排序规则来确定其位置
* 在查找时具有非常好的性能
* 通常以平衡二叉树方式实现，插入和检索的时间都是`O(logN)`
1. `set/multiset`：头文件<set>
    * set即集合，set不允许相同元素，multiset中允许存在相同的元素
2. `map/multimap`：头文件<map>
    * map与set的不同在于map中存放的元素有且仅有两个成员变量，一个名为first，另一个名为second，map根据first值对元素进行从小到大排序，并可快速地根据first来检索元素
    * map与multimap的不同在于是否允许相同first值的元素
# 容器适配器简介
1. `stack`；头文件<stack>
    * 栈，是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项（栈顶的顶），即后进先出
2. `queue`：头文件<queue>
    * 队列，插入只可以在尾部进行，删除、检索和修改只允许从头部进行，即先进先出
3. `priority_queue`：头文件<queue>
    * 优先级队列，最高优先级元素总是第一个出列
# 顺序容器和关联容器中都有的成员
* `begin`返回指向容器中第一个元素的迭代器
* `end`返回指向容器中最后一个元素的后面的位置的迭代器
* `rbegin`返回指向容器中最后一个元素的迭代器
* `rend`返回指向容器中第一个元素前面的位置的迭代器
* `erase`从容器中删除一个或几个元素
* `clear`从容器中删除所有元素
# 顺序容器的常用成员函数
* `front`返回容器中第一个元素的引用
* `back`返回容器中最后一个元素的引用
* `push_back`在容器末尾增加新元素
* `pop_back`删除容器末尾新元素
* `erase`删除迭代器指向的元素（可能会使该迭代器失效），或删除一个区间，返回被删除元素后面的那个元素的迭代器
