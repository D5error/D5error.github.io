# 快速排序（课上讲解，简短）
```c
void swap(int &a, int &b)
{
    int t = a; 
    a = b;
    b = t;
}

int partiton(int arr[], int low, int high)
{
    int pivot = arr[high], i = low;
    for(int j = low; j < high; j++)
    {
        if(arr[j] < pivot)
        {
            swap(arr[j], arr[i++]);
        }
    }
    swap(arr[i], arr[high]);
    return i;
}

void quick_sort(int arr[], int low, int high)
{
    if(low < high)
    {
        int k = partition(arr, low, high);
        quick_sort(arr, low, k - 1);
        quick_sort(arr, k + 1, high);
    }
}
```

# 快速排序（普通）

```C
ElementType Median3( ElementType A[],int Left,int Right)
{ 
    int Center=(Left+Right)/2;
    if (A[Left]>A[Center])    //左边比中间大就交换
        Swap(&A[Left],&A[Center]);
    if (A[Left]>A[Right])    //左边比右边大就交换
        Swap(&A[Left],&A[Right]);
    if (A[Center]>A[Right])    //中间比右边大就交换
        Swap(&A[Center],&A[Right]);
    Swap(&A[Center],&A[Right-1]);    //将基准Pivot藏到右边倒数第二个位置
    return  A[Right-1];    //返回基准Pivot
}
void Qsort(ElementType A[],int Left,int Right)
{
     int Pivot,Cutoff,Low,High;    //Cutoff:最大匹配数阈值,可以认为是代码中对于'较少'和'较多'的分界线
     if (Cutoff<=Right-Left)
     {
          Pivot=Median3(A,Left,Right);    //选基准
          Low=Left;
          High=Right-1;
          while(1)    //实现左边比基准小,右边比基准大
          {
            while(A[++Low]<Pivot);    //左边找到比基准大的
            while(A[--High]>Pivot);    //右边找到比基准小的
            if(Low<High)
                Swap(&A[Low],&A[High]);
            else 
                break;
          }
          Swap(&A[Low],&A[Right-1]);    //将基准换回正确位置,此时Low在基准正确的位置上
          Qsort(A,Left,Low-1);    //对左部分快速排序
          Qsort(A,Low+1,Right);    //对右部分快速排序
     }
     else
        InsertionSort( A+Left, Right-Left+1 );    //元素较少,使用简单排序
}

//统一函数接口
void QuickSort(ElementType A[],int N)
{
     Qsort(A,0,N-1);
}
```
