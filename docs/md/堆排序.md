## 1. 堆排序

* 算法1:T(N)=O(NlogN),需要额外O(N)空间,并且复制元素需要时间,不好用
* 思路:对数组建立最小堆,依次取出最小值,最后进行复制

```C
void Heap_Sort(ElementType A[],int N)
{
    BuildHeap(A);    //O(N)
    for(i=0;i<N;i++)
        TmpA[i]=DeleteMin(A);    //O(logN)
    for(i=0;i<N;i++)
        A[i]=TmpA[i];
}
```

* 算法2:T(N)=2NlogN-O(NloglogN),比算法1好用,虽然堆排序给出最佳平均时间复杂度,但实际效果不如用Sedgewick增量序列的希尔排序
* 注意,该算法无哨兵,即数组下标从0开始,n的左堆和右堆为2n+1和2n+2
* 思路:对数组建立最大堆,每次将最大值放置后面有序区,接着对无序区进行下滤

```C
void PeercDown(ElementType A[],int p,int N)
{
    int Parent,Child;
    ElementType X;
    X=A[p];    //取出根结点的值
    for(Parent=p;(Parent*2+1)<N;Parent=Child)
    {
        Child=Parent*2+1;
        if((Child!=N-1)&&(A[Child]<A[Child+1]))   //找值大的儿子
            Child++;
        if(X>=a[Child])
            break;
        else
            A[Parent]=A[Child];    //儿子的值比父亲大,取代父亲
    }
    A[Parent]=X;
}
void Heap_Sort(ElementType A[],int N)
{
    for(i=N/2-1;i>=0;i--)    //该循环等价于BuildHeap(A);
        PercDown(A,i,N);    //下滤,以i为根的子堆调整为最大堆
    for(i=N-1;i>0;i--)
    {
        Swap(&A[0],&A[i]);    //每次将当前最大值A[0]放置于A[i]
        PercDown(A,0,i);    //放置后进行下滤
    }
}
```
