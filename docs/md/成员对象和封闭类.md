# 成员对象和封闭类
* 有成员对象的类叫封闭类

```c
class CA
{
    public:
        int a;
        CA(int i):a(i){}
};
class CB
{
    public:
        int b;
};
class CC
{
    private:
        int x;
        CA obj1;
        CB obj2;
    public:
        CC(int a,int b,int c):obj1(a),obj2(b),x(c){}
        void Print()
        {
            cout<<obj1.a<<endl;
            cout<<obj2.b<<endl;
            cout<<x<<endl;
        }
};
int main()
{
    CC obj(1,2,3);
    obj.Print();
    return 0;
}
```

* 如果CC类不定义构造和拿书，则下面语句会报错`CC obj;`，因为编译器不明白obj1该如何初始化。而obj2的初始化没问题，因为有默认的构造函数

* 任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象，是如何初始化的

* 具体的做法是：通过封闭类的构造函数的初始化列表

* 成员对象的初始化列表中的参数可以是任意复杂的表达式，可以包括函数，变量，只要表达式中的函数或变量有定义就行

* 封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数

* 对象成员的构造函数**调用次序和对象成员在类中的说明次序一致**，与它们在成员初始化列表中出现的次序**无关**

* 当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数，**次序和构造函数的调用次序相反**
