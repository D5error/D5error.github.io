# 1. 朴素贝叶斯

* 贝叶斯理论:
    * 现在有一个数据集，它由两类数据组成
    
    ![朴素贝叶斯](https://note.youdao.com/yws/api/personal/file/WEB43d4f6d681245e782e2a7cab4ec83386?method=download&shareKey=7410ef973c347696828235bfa773dee3)

    * 现在用p1(x,y)表示数据点(x,y)属于类别1(图中圆点表示的类别)的概率,用p2(x,y)属于类别2(图中三角形表示的类别)的概率,那么对于一个新的数据点(x,y),可以用下面的规则来判断它的类别:
        * 如果p1(x,y)>p2(x,y),那么类别为1
        * 如果p2(x,y)>p1(x,y),那么类别为2

    * 也就是说,我们会选择高概率对应的类别,这就是贝叶斯决策理论的核心思想,即选择具有最高概率的决策

* 朴素贝叶斯场景:
    * 机器学习的一个重要应用就是文档的自动分类
    * 在文档分类中,整个文档(如一封电子邮件)是实例,而电子邮件中的某些元素则构成特征,我们可以观察文档中出现的词,并把每个词作为一个特征,而每个词的出现或者不出现作为该特征的值,这样得到的特征数目就会跟词汇表中的词的数目一样多

## 2. 朴素贝叶斯原理

* 朴素贝叶斯工作原理

```
提取所有文档中的词条并进行去重
获取文档中的所有类别
计算每个类别中的文档数目
对每篇训练文档:
    对每个类别:
        如果词条出现在文档中-->增加该词条的计数值(for循环或矩阵相加)
        增加所有词条的计数值(此类别下词条总数)
对每个类别:
    对每个词条:
        将该词条的数目除以总词条数目得到的条件概率(P(词条|类别))
返回该文档属于每个类别的条件概率(P(类别|文档的所有词条))
```

* 朴素贝叶斯算法特点:
    * 优点:在数据较少的情况下仍然有效,可以处理多类别的问题
    * 缺点:对于输入数据的准备方式较为敏感
    * 适用数据类型:标称型数据

## 3.项目案例

* 屏蔽社区留言版的侮辱性言论

```python
import random
import numpy as np

def 创建数据集():#创建数据集
    数据集=[['my','dog','has','flea','problems','help','please'],
                 ['maybe','not','take','him','to','dog','park','stupid'],
                 ['my','dalmatian','is','so','cute','I','love','him'],
                 ['stop','posting','stupid','worthless','garbage'],
                 ['mr','licks','ate','my','steak','how','to','stop','him'],
                 ['quit','buying','worthless','dog','food','stupid']]
    标签=[0,1,0,1,0,1]#1表示具有冒犯性
    return 数据集,标签

def 创建单词表(数据集):#获取所有单词的集合
    单词表=set([])#建立空集
    for 行 in 数据集:
        单词表=单词表|set(行)#操作符‘|’用于求两集合的并集
    return list(单词表)

def 创建行存在表(词汇表, 行):#遍历查看lineSet中的单词是否出现在wordlist中，出现则该单词置1
    行存在表=[0]*len(词汇表)#初始化和单词表等长的向量
    for 单词 in 行:
        if 单词 in 词汇表:
            行存在表[词汇表.index(单词)]=1
        else:
            print('该文本中的单词均不存在于词汇表中!')
    return 行存在表

def 训练朴素贝叶斯(数据集行单词存在表数组, 数据集行标签数组):
    数据集总行数=len(数据集行单词存在表数组)
    数据集总单词数=len(数据集行单词存在表数组[0])
    行出现侮辱行概率=sum(数据集行标签数组)/float(数据集总行数)#侮辱性句子出现概率
    全非侮辱行单词存在表=np.ones(数据集总单词数)#初始化为1防止计算异常
    全侮辱行单词存在次数表=np.ones(数据集总单词数)#初始化为1防止计算异常
    非侮辱行总单词数=2.0
    侮辱行总单词数=2.0
    for 行 in range(数据集总行数):
        if 数据集行标签数组[行]==1:
            全侮辱行单词存在次数表+=数据集行单词存在表数组[行]#记录侮辱行都有哪些单词
            侮辱行总单词数+=sum(数据集行单词存在表数组[行])#记录侮辱行有多少词汇量
        else:
            全非侮辱行单词存在表+=数据集行单词存在表数组[行]
            非侮辱行总单词数+=sum(数据集行单词存在表数组)
    侮辱词频取对=np.log(全侮辱行单词存在次数表/侮辱行总单词数)#取自然对数
    非侮辱词频取对=np.log(全非侮辱行单词存在表/非侮辱行总单词数)#取自然对数
    return 非侮辱词频取对,侮辱词频取对,行出现侮辱行概率

def 分类朴素贝叶斯(测试集行单词存在表,非侮辱词频取对,侮辱词频取对,行出现侮辱行概率):
    print(sum(测试集行单词存在表*侮辱词频取对)+np.log(行出现侮辱行概率))
    p1=sum(测试集行单词存在表*侮辱词频取对)+np.log(行出现侮辱行概率)
    p0=sum(测试集行单词存在表*侮辱词频取对)+np.log(1.0-行出现侮辱行概率)
    if p1>p0:
        return 1
    else:
        return 0

def 测试朴素贝叶斯():
    数据集,数据集行标签=创建数据集()#加载数据集
    数据集词汇表=创建单词表(数据集)#建立data的词汇表
    数据集行单词存在表=[]
    for 行 in 数据集:
        数据集行单词存在表.append(创建行存在表(数据集词汇表, 行))
    非侮辱词频取对,侮辱词频取对,行出现侮辱行概率=训练朴素贝叶斯(np.array(数据集行单词存在表), np.array(数据集行标签))
    测试集=['love','my','dalmatian']
    测试集行单词存在表=np.array(创建行存在表(数据集词汇表,测试集))
    print(测试集,'classified as: ',分类朴素贝叶斯(测试集行单词存在表,非侮辱词频取对,侮辱词频取对,行出现侮辱行概率))

if __name__=='__main__':
    测试朴素贝叶斯()
```