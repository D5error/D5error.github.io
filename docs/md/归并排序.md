## 1. 归并排序

* 有序子序列的归并(一个数组中两个区块已经排序好)

![归并排序1](https://note.youdao.com/yws/api/personal/file/WEBc9c6b71d5e993a9bdd7056b17eb6af1e?method=download&shareKey=22dd6b9d4850306aa3b8dc3b4ca05459)

```C
void Merge(ElementType A[],ElementType TmpA[],int L,int R,int RightEnd)
//L=左边起始位置,R=右边起始位置,RightEnd=右边终点位置
{
    LeftEnd=R-1;    //左边终点的位置,假设左右两列紧邻
    Tmp=L;    //存放结果数组的初始位置
    NumElements=RightEnd-L+1;
    while(L<=LeftEnd&&R<=RightEnd)
    {
        if(A[L]<A[R])
            TmpA[Tmp++]=A[L++];
        else
            TmpA[Tmp++]=A[R++];
    }
    while(L<=LeftEnd)    //左边没读完,继续读
        TmpA[Tmp++]=A[L++];
    while(R<=RightEnd)    //右边没读完,继续读
        TmpA[Tmp++]=A[R++];
    for(i=0;i<NumElements;i++,RightEnd--)    //返回整理好的元素
        A[RightEnd]=TmpA[RightEnd]
}
```

* 递归算法

    * T(N)=T(N/2)+T(N/2)+O(N)=>T(N)=O(NlogN)

![归并排序2](https://note.youdao.com/yws/api/personal/file/WEBb5acfcbe2a5a5b3ddf9a729ed6759da3?method=download&shareKey=cbc4b3c175e2de590a8765fe4e6b3b60)

```C
void MSort(ElementType A[],ElementType TmpA[],int L,int RightEnd)
{
    int Center;
    if(L<RightEnd)
    {
        Center=(L+RightEnd)/2;
        MSort(A,TmpA,L,Center);    //整理左半边
        MSort(A,TmpA,Center+1,RightEnd);    //整理右半边
        Merge(A,TmpA,L,Center+1,RightEnd);    //归并两边,用的是上面的函数
    }
}

//统一函数接口
void Merge_sort(ElementType A[],int N)
{
    ElementType *TmpA;
    TmpA=malloc(N*sizeof(ElementType));
    if(TmpA!=NULL)
    {
        MSort(A,TmpA,0,N-1);
        free(TmpA);
    }
    else
        Error("空间不足!\n");
}
```

* 非递归算法

```C
void MergeSort_pass(ElementType A[],ElementType TmpA[],int N,int length)
//length=当前有序子列的长度
/*
---------|------------|---------------|---------------
         |            |               |
---------|------------|---------------|---------------
         i         i+length       i+2*length
*/
{
    for(i=0;i<N-2*length;i+=2*length)    //切等长length,每两份进行归并
        Merge(A,TmpA,i,i+length,i+2*length-1);    //将A归并到TmpA
    if(i+length<N)    //对最后两份归并
        Merge(A,TmpA,i,i+length,N-1);
    else    //最后只剩一份
        for(j=i;j<N;j++)    //由于每份局部已整理好,故直接并入
            TmpA[j]=A[j];
}

//统一函数接口
void Merge_sort(ElementType A[],int N)
{
    ElementType *TmpA;
    TmpA=malloc(N*sizeof(ElementType));
    if(TmpA!=NULL)
    {
        while(length<N)
        {
            Merge_pass(A,TmpA,N,length);    //将A归并到TmpA
            length*=2;
            Merge_pass(TmpA,A,N,length);    //将TmpA归到A
            length*=2;
        }
        free(TmpA);
    }
    else
        Error("空间不足!\n");
}
```
