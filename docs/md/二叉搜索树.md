# 什么是二叉搜索树
1. 非空左子树的所有键值**都小于**其根结点的键值

2. 非空右子树的所有键值大于其根结点的键值

3. 左右子树都是二叉搜索树

# 二叉搜索树可参考“平衡二叉树”小节的代码，下面已作废

# 二叉搜索树的操作（作废）

* 查找

```cpp
//递归法
Position Find(ElementType X,BinTree BST)
{
    if(!BST)
    {
        return NULL;
    }
    if(X>BST->Data)
    {
        return Find(X,BST->Right);
    }
    else if(X<BST->Data)
    {
        return Find(X,BST->Left);
    }
    return BST;
}
```

```cpp
//循环法
Position IterFind(ElementType X,BinTree BST)
{
    while(BST)
    {
        if(X>BST->Data)
        {
            BST=BST->Right;
        }
        else if(X<BST->Data)
        {
            BST=BST->Left;
        }
        else
        {
            return BST;
        }
    }
    return NULL;
}
```

* 最小查找

```cpp
Position FindMin(BinTree BST)
{
    if(BST)
    {
        while(BST->Left)
        {
            BST=BST->Left;
        }
    }
    return BST;
}
```

* 最大查找

```cpp
Position FIndMax(BinTree BST)
{
    if(BST)
    {
        while(BST->Right)
        {
            BST=BST->Right;
        }
    }
    return BST;
}
```

* 插入

```cpp
BinTree Insert(ElementType X,BinTree BST)
{
    if(!BST)//空树情况
    {
        BST=(BinTree)malloc(sizeof(struct TreeNode));
        BST->Data=X;
        BST->Left=BST->Right=NULL;
    }
    else
    {
        if(X<BST->Data)
        {
            BST->Left=Insert(X,BST->Left);
        }
        else if(X>BST->Data)
        {
            BST->Right=Insert(X,BST->Right);
        }
    }
    return BST;
}
```

* 删除

```cpp
BinTree Delete(ElementType X,Bintree BST)
{
    Position Tmp;
    if(!BST)
    {
        printf("要删除的元素未找到");
    }
    else if(X<BST->Data)
    {
        BST->Left=Delete(X,BST->Left);
    }
    else if(x>BST->Data)
    {
        BST->Right=Delete(X,BST->Right);
    }
    else
    {
        if(BST->Left&&BST->Right)
        {
            Tmp=FindMin(BST->Right);
            BST->Data=Tmp->Data;
            BST->Right=Delete(BST->Data,BST->Right);
        }
        else//最多一个子树，只有一个就直接接上即可
        {
            Tmp=BST;
            if(!BST->Left)
            {
                BST=BST->Right;
            }
            else if(!BST->Right)
            {
                BST=BST->Left;
            }
            free(Tmp);
        }
    }
    return BST;
}
```
