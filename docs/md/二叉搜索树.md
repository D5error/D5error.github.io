## 1. 什么是二叉搜索树
 
* 非空左子树的所有键值小于其根结点的键值
* 非空右子树的所有键值大于其根结点的键值
* 左右子树都是二叉搜索树

## 2. 二叉搜索树的操作

* 查找

```
Position Find(ElementType X,BinTree BST)
{
    if(!BST)
    {
        return NULL;
    }
    if(X>BST->Data)
    {
        return Find(X,BST->Right);
    }
    else if(X<BST->Data)
    {
        return Find(X,BST->Left);
    }
    return BST;
}
```

```
Position IterFind(ElementType X,BinTree BST)
{
    while(BST)
    {
        if(X>BST->Data)
        {
            BST=BST->Right;
        }
        else if(X<BST->Data)
        {
            BST=BST->Left;
        }
        else
        {
            return BST;
        }
    }
    return NULL;
}
```

* 最小查找

```
Position FindMin(BinTree BST)
{
    if(!BST)
    {
        return NULL;
    }
    else if(!BST->Left)
    {
        return BST;
    }
    return FindMin(BST->Left);
}
```

* 最大查找

```
Position FIndMax(BinTree BST)
{
    if(BST)
    {
        while(BST->Right)
        {
            BST=BST->Right;
        }
    }
    return BST;
}
```

* 插入

```
BinTree Insert(ElementType X,BinTree BST)
{
    if(!BST)
    {
        BST=(BinTree)malloc(sizeof(struct TreeNode));
        BST->Data=X;
        BST->Left=BST->Right=NULL;
    }
    else
    {
        if(X<BST->Data)
        {
            BST->Left=Insert(X,BST->Left);
        }
        else if(X>BST->Data)
        {
            BST->Right=Insert(X,BST->Right);
        }
    }
    return BST;
}
```

* 删除

```
BinTree Delete(ElementType X,Bintree BST)
{
    Position Tmp;
    if(!BST)
    {
        printf("要删除的元素未找到");
    }
    else if(X<BST->Data)
    {
        BST->Left=Delete(X,BST->Left);
    }
    else if(x>BST->Data)
    {
        BST->Right=Delete(X,BST->Right);
    }
    else
    {
        if(BST->Left&&BST->Right)
        {
            Tmp=FindMin(BST->Right);
            BST->Data=Tmp->Data;
            BST->Right=Delete(BST->Data,BST->Right);
        }
        else
        {
            Tmp=BST;
            if(!BST->Left)
            {
                BST=BST->Right;
            }
            else if(!BST->Right)
            {
                BST=BST->Left;
            }
            free(Tmp);
        }
    }
    return BST;
}
```
